define(['mcscript','files'],function(mcscript,files){
  function compile(){
    this.compiledFiles = [];
    //console.log(mcscript);
  }
  compile.prototype = {
    compile: function(files){
      // var testfile = files[0].content.replace(/([^\,\;\(\{\[])(\n)/g,function(match,p1,p2){return p1+";\n"})
      // console.log(mcscript.gen.parseCode(mcscript.parser.parse(mcscript.lexer.lexer(testfile))),"file.mcscript")
      this.compiledFiles = this.compileFiles(files);//got to return something that i can work with in an actual functional style.
      //now to do things with output. ohhhh boy. copy pasting project.
      var data = {}
      //data["dir"] = this.compiledFiles[0].dir.split("/")[0];
      data["name"] = this.compiledFiles[0].name.split("/")[0]+"/"+"pack.mcmeta"
      data["data"] = "{\n\t\"pack\": {\n\t\t\"pack_format\": 1,\n\t\t\"description\": \"generated by mcscriptStudio, a MCScript based application.\"\n\t}\n}"
      this.compiledFiles.push(data);

      window.running.interface.files.output = window.running.interface.files.treeFolders(this.compiledFiles);
    },
    //porting the mcscript forweb into here.
    recurseForEach: function(file,regex,depth,specialDigit){
      file = file.split(new RegExp(regex[depth],'g'));
      if(depth+1<regex.length)
        for(var i = 0; i<file.length;i++){
          file[i]=this.recurseForEach(file[i],regex,depth+1,specialDigit)
        }
      file = file.join(regex[depth].replace(/([\d]+)/,"")+(specialDigit+depth));
      return file;
    },
    fileName: function(file,parentFile){
      //so there are a few cases i need to handle.
      // if the first folder of the extend name equals the first part of the project name it is a direct path
      // if there is a .., it needs to understand that this goes up a folder.
      // if there are too many .., it needs to understand that this is invalid. or just stop on the parent directory.
      // if there is just a ./filename, it can take the parentfiles dir and add that to itself, all done.
      // OH there is also the potential of a file that has ../newfolder/file or even ../newfolder/../newfile etc. this should be ok with the above.
      //handeling those will be a nightmare, but should be possible.
      //so working backwards i guess.
      // and that is what i did. this works now.
      var thisdir = parentFile.dir;
      var thisfile = file.replace(/(^|\/)\.\//,'$1'); //filters out .//
      //console.log(thisfile);
      if(thisfile.match(/^\/./)){//prep direct file paths. anything starting with /
        thisdir = thisfile.match(/^.*?(?=\/\.\.|\/[^\/.]*$)/)[0];
        thisfile = thisfile.substring(thisdir.length+1);
      }
      var backdir = (thisdir+'/'+thisfile).split(/\//);
      thisdir = '';
      thisfile = backdir[backdir.length-1];
      var skip = 0;
      for(var i = backdir.length-2;i>=0;i--){
        if(backdir[i]==='..')
          skip++;
        else{
          if(skip>0)
            skip--;
          else
            thisdir = backdir[i] + '/' + thisdir;
        }
      }
      if(thisdir[0]==='/')
        thisdir = thisdir.substring(1);
      return thisdir+thisfile;
    },
    compileFiles: function(rawFiles){
      //so this keeps the file tree, as that is important to the compilation.
      //the functions are in the folder for the functions. eg the projects is the datapack name
      //then the files in the parent dir are placed straight in functions.
      //ex: proj/data/proj/functions/STUFF.
      //something important as well: order of files in importance:
      //compiled comes first, declared files. first come are first served.
      //then comes comes the edited and tagged files. they are also first come first served. edited contains both tagged and edited files.
      var specialDigit = 0;
      var compiledFiles = [];
      var editedFiles = [];
      var taggedFiles = [];//[{'minecraft:load':'mcscript/load.mcfunction'},{'minecraft:tick':''}];//auto load mcscript delcarations.
      for(var file of rawFiles){
        var input = file.content.replace(/([^\n,;({[])([\n])/g,'$1;\n').replace(/\n([\s]+);/g,'\n');
        var directory = file.dir;
        var ast = mcscript.parse(mcscript.TokenStream(mcscript.InputStream(input,file.dir.split("functions")[1]+'/'+file.name)));
        var data = mcscript.generate(ast,file.name,file.dir.split("/")[0],'/'+file.dir.split("functions")[0]+"functions");
        let savedData = data;
        var forReplace = data.match(/(?:mcscript\/)((?:foreach|forEach|dowhile|raycast|while)[\d]+)/g);
        if(forReplace){
          var seen = {}
          forReplace = forReplace.filter(function(item){
            return seen.hasOwnProperty(item) ? false : (seen[item]=true);
          });
          var test = []
          data = this.recurseForEach(data,forReplace,0,specialDigit);
          specialDigit+=forReplace.length;
        }
        //console.log(data);
        //let compiledFiles = [];
        // console.log(data.startsWith(file.dir+"/"+file.name.replace(/\.mcscript/,"")),file.dir+"/"+file.name.replace(/\.mcscript/,""),data);
        // data = file.dir+"/"+file.name.replace(/\.mcscript/,"")+"\n"+data;
        //console.log(file.dir);
        if(file.name.endsWith('load.mcscript')){
          directory = directory.split("functions")[0]+"functions"
          data = '#file: ./mcscript/load\n#tagged: minecraft:load, ./mcscript/load\n' + data;
        }
        else {
          data = '#file: /'+file.dir+'/'+file.name.split('.mcscript')[0]+'\n'+data;
        }
        data = data.split("#file: ").splice(1)//data.match(/((?:^|#file:)(?:[^]*?)(?=#file:|$))/);
        var that = this;



        //new file managment stuff is going to go below.
        data.forEach(function(exp,i,fileinfo){
          // console.log(exp.split(/#(?:tagged|extend): /g)[0].match(/.*?(?=\n)/),file.dir);
          var allFiles = exp.split(/#(tagged|extend): /g);
          //console.log(that.fileName(allFiles[0].match(/.*/)[0],file))//always should be the filename for the thing. YEP
          var thisfilename = that.fileName(allFiles[0].match(/.*/)[0],file);
          compiledFiles.push({name:thisfilename+'.mcfunction',data: allFiles[0].replace(/.*\n/,'')});
          if(allFiles.length>1){
            allFiles.slice(1).forEach(function(ext,j,part){
              //console.log(ext,compiledFiles)
              if(ext==='extend'){
                //console.log(part[j+1].match(/.*/));
                editedFiles.push({name:that.fileName(part[j+1].match(/.*/)[0],file)+'.mcfunction',data:'\n#Extended from '+file.dir+'/'+file.name+'\n'+part[j+1].replace(/.*\n/,'')});
                //console.log(that.fileName(part[j+1].match(/.*/)[0],file)); //so this works basically in every case. sweet.
              }
              else if(ext==='tagged'){
                var totag = part[j+1].match(/(^[^\s,]*)(?:, )(.*)/).slice(1);
                totag[1] = that.fileName(totag[1],file)//so 1 will be the tag file, 2 will be the tagged file. nice.
                editedFiles.push({name:totag[1]+'.mcfunction',data:'\n#Tagged into '+totag[0]+' and extended from '+file.dir+'/'+file.name+'\n'+part[j+1].replace(/.*\n/,'')});//add the edited file.
                taggedFiles.push({name:totag[1].match(/((.*?\/){2})/)[0]+''+totag[0].split(':')[0]+'/tags/functions/'+totag[0].split(':')[1]+'.json',data:totag[1].match(/(?:data\/)(.+?)(?:\/functions\/)(.*)/).slice(1)[0]+':'+totag[1].match(/(?:data\/)(.+?)(?:\/functions\/)(.*)/).slice(1)[1]})
                //handle the tagged part of the file, then just extend it.
                //console.log(part[j+1].match(/.*/))
              }
            })
          }
        });
      }
      //if there are any duplicate files, merge them.
      for(var i in compiledFiles){
        for(var j = i; j<compiledFiles.length;j++){
          if(compiledFiles[i].name===compiledFiles[j].name&&i!=j){
            compiledFiles[i].data = compiledFiles[i].data+'\n'+compiledFiles[j].data;
            // console.log(compiledFiles.splice(j,1));
            compiledFiles.splice(j,1);
            j--;
          }
        }
      }
      //add the edited files
      for(var i = 0; i<editedFiles.length;i++){
        let editFiles = compiledFiles.find(function (obj) { if (obj.name === editedFiles[i].name) return obj});
        if(editFiles) compiledFiles[compiledFiles.indexOf(editFiles)].data = compiledFiles[compiledFiles.indexOf(editFiles)].data+editedFiles[i].data;
        else {
          compiledFiles.push({name: editedFiles[i].name, data: editedFiles[i].data});
        }
      }
      //finally add the tagged files.
      for(var i =0; i<taggedFiles.length;i++){
        var toTag = [taggedFiles[i].data]
        for(var j = i; j<taggedFiles.length;j++){
          if(i!=j && taggedFiles[i].name===taggedFiles[j].name){
            toTag.push(taggedFiles[j].data)
            taggedFiles.splice(j,1);
            j--;
          }
        }
        var seen = {}
        toTag = toTag.filter(function(item){
          return seen.hasOwnProperty(item) ? false : (seen[item]=true);
        }).join('",\n\t\t"');
        taggedFiles[i].data = '{\n\t"values":[\n\t\t"'+toTag+'"\n\t]\n}'
      }
      compiledFiles = compiledFiles.concat(taggedFiles);
      //console.log(compiledFiles,editedFiles,taggedFiles);
      return compiledFiles;
      //this compiles the files for the thing, this is very nice! modified from forWeb.js
      //prepped input text for compiling.
    }
  }
  return compile;
});
